var documenterSearchIndex = {"docs":
[{"location":"modules/astroConstants/#Astrodynamics-Constants","page":"Astrodynamics Constants","title":"Astrodynamics Constants","text":"","category":"section"},{"location":"modules/astroConstants/","page":"Astrodynamics Constants","title":"Astrodynamics Constants","text":"Inside this module, relevant and useful constants to solve astrodynamics problems are defined. ","category":"page"},{"location":"modules/astroConstants/","page":"Astrodynamics Constants","title":"Astrodynamics Constants","text":"PHYSICAL CONSTANTS","category":"page"},{"location":"modules/astroConstants/","page":"Astrodynamics Constants","title":"Astrodynamics Constants","text":"Gravitational constant, G [m^3(kg*s^2)]: G = 6.67408e-11\nBoltzmann constant, k [m^2*kg(s^2*K)]: k = 1.38064852e-23\nStefan-Boltzmann constant, sigma [W(m^2*K^4)]: const sigma = 5.670367e-8\nSpeed of light in vacuum, c [ms]: const c = 299792458.0","category":"page"},{"location":"modules/astroConstants/","page":"Astrodynamics Constants","title":"Astrodynamics Constants","text":"CELESTIAL BODY DATA (from NASA's planetary fact sheet - Date: 11-02-2023)","category":"page"},{"location":"modules/astroConstants/","page":"Astrodynamics Constants","title":"Astrodynamics Constants","text":"Gravitational parameter, mu [km^3s^2]:\nmu_Sun = 1.32712440018e11\nmu_Mercury = 2.2032e4\nmu_Venus = 3.24859e5\nmu_Earth = 398600.4418\nmu_Moon = 4902.800066\nmu_Mars = 4.282837e4\nmu_Jupiter = 1.26687e8\nmu_Saturn = 3.7931187e7\nmu_Uranus = 5.79395e6\nmu_Neptune = 6.836510e6","category":"page"},{"location":"modules/astroConstants/","page":"Astrodynamics Constants","title":"Astrodynamics Constants","text":"Mean body radius, R [km]:\nR_Sun = 6.957e5\nR_Mercury = 2.4397e3\nR_Venus = 6.0518e3\nR_Earth = 6.371e3\nR_Moon = 1.7374e3\nR_Mars = 3.3895e3\nR_Jupiter = 6.9911e4\nR_Saturn = 5.8232e4\nR_Uranus = 2.5362e4\nR_Neptune = 2.4622e4","category":"page"},{"location":"modules/astroConstants/","page":"Astrodynamics Constants","title":"Astrodynamics Constants","text":"Eccentricity, e [-]:\ne_Mercury = 0.2056\ne_Venus = 0.0068\ne_Earth = 0.0167\ne_Moon = 0.0549\ne_Mars = 0.0935\ne_Jupiter = 0.0487\ne_Saturn = 0.0520\ne_Uranus = 0.0469\ne_Neptune = 0.0097","category":"page"},{"location":"modules/astroConstants/","page":"Astrodynamics Constants","title":"Astrodynamics Constants","text":"Semi-major axis, a [km]:\na_Mercury = 5.790905e7\na_Venus = 1.08209e8\na_Earth = 1.49598e8\na_Moon = 3.8475e5\na_Mars = 2.2796e8\na_Jupiter = 7.7848e8\na_Saturn = 1.4320e9\na_Uranus = 2.8670e9\na_Neptune = 4.5150e9","category":"page"},{"location":"modules/astroConstants/","page":"Astrodynamics Constants","title":"Astrodynamics Constants","text":"Sidereal rotation rate of the body about its axis, omega [rads]:\nomega_Mercury = 1.240014e-6\nomega_Venus = -0.29924e-6\nomega_Earth = 7.292115e-5\nomega_Moon = 2.6617e-6\nomega_Mars = 7.088218e-5\nomega_Jupiter = 1.7585e-4\nomega_Saturn = 1.63785e-4\nomega_Uranus = -1.01237e-4\nomega_Neptune = 1.08338e-4","category":"page"},{"location":"modules/astroConstants/","page":"Astrodynamics Constants","title":"Astrodynamics Constants","text":"Oblateness parameter of the body's gravitational field, J2 [-]:\nJ2_Mercury = 5.03e-5\nJ2_Venus = 4.458e-6\nJ2_Earth = 1.08263e-3\nJ2_Moon = 2.027e-4\nJ2_Mars = 1.96045e-3\nJ2_Jupiter = 1.4736e-2\nJ2_Saturn = 1.6298e-2\nJ2_Uranus = 3.34343e-3\nJ2_Neptune = 3.411e-3","category":"page"},{"location":"modules/astroConstants/","page":"Astrodynamics Constants","title":"Astrodynamics Constants","text":"Mass of the body, M [kg]:\nM_Sun = 1.988544e30\nM_Mercury = 3.302e23\nM_Venus = 4.8685e24\nM_Earth = 5.97219e24\nM_Moon = 7.34767309e22\nM_Mars = 6.4171e23\nM_Jupiter = 1.89813e27\nM_Saturn = 5.68319e26\nM_Uranus = 8.68103e25\nM_Neptune = 1.0241e26","category":"page"},{"location":"modules/orbitalPlots/#Orbital-Visualization","page":"Orbital Visualization","title":"Orbital Visualization","text":"","category":"section"},{"location":"modules/orbitalPlots/","page":"Orbital Visualization","title":"Orbital Visualization","text":"One of the main objectives of this library is not only to allow the computation of orbital dynamics but also the visualization of orbits in an appealing and engaging way. ","category":"page"},{"location":"modules/orbitalPlots/","page":"Orbital Visualization","title":"Orbital Visualization","text":"The orbitalPlots.jl file provides a powerful toolset for generating high-quality orbit representations using the Plots package in Julia. By leveraging the capabilities of Plots, this module enables the creation of visually appealing and informative plots of various orbital elements and parameters","category":"page"},{"location":"modules/orbitalPlots/","page":"Orbital Visualization","title":"Orbital Visualization","text":"Upon initial use, it is worth noting that the orbitalPlots.jl file, and therefore the package, may take some time to load due to its dependence on the heavy Plots package. However, once loaded, the module functions smoothly and efficiently. In some cases, when writing code outside of the terminal, it may be necessary to include the display() function to ensure that the plots are rendered and displayed correctly.","category":"page"},{"location":"modules/orbitalPlots/","page":"Orbital Visualization","title":"Orbital Visualization","text":"Because of the relevance and regularity of these reference frames, this module allows to plot orbits in both the ECI and the perifocal reference frames. In the perifocal reference frame, the plots are done in the perifocal plane, in 2D. It uses the gr() backend to visualize them. Whereas, the plots in ECI reference frame are in 3D, and use the plotly(). The reason behind using this backend for the ECI plots instead of gr(), is that plotly() allows the user not only to visualize but also to interact with it. One is able to move around the plot and observe the orbit from a different perspective. For aesthetic reasons, both use :juno theme from PlotThemes.","category":"page"},{"location":"modules/orbitalPlots/","page":"Orbital Visualization","title":"Orbital Visualization","text":"The following examples showcase the visualization of orbits in the perifocal (PF) coordinate system, providing insights into the shape, size, and orientation of the orbits. ","category":"page"},{"location":"modules/orbitalPlots/","page":"Orbital Visualization","title":"Orbital Visualization","text":"(Image: Alt text) (Image: Alt text) (Image: Alt text)","category":"page"},{"location":"modules/orbitalPlots/","page":"Orbital Visualization","title":"Orbital Visualization","text":"Additionally, an example in the Earth-Centered Inertial (ECI) coordinate system is also presented in the following figure. It shows a satellite in a LEO (Low Earth Orbit) around Earth. This coordinate system is commonly used in space missions and satellite tracking.","category":"page"},{"location":"modules/orbitalPlots/","page":"Orbital Visualization","title":"Orbital Visualization","text":"(Image: Alt text)","category":"page"},{"location":"modules/orbitalPlots/","page":"Orbital Visualization","title":"Orbital Visualization","text":"These examples serve as valuable references for understanding the behavior and characteristics of various types of orbits. Whether it's a circular orbit, elliptical orbit, or more complex trajectories, the orbitalPlots.jl file empowers students to gain deeper insights into orbital dynamics through visually compelling representations.","category":"page"},{"location":"modules/orbitalPlots/","page":"Orbital Visualization","title":"Orbital Visualization","text":"In the following table it can be seen the functions needed to do each plot, as well as the inputs required. There also appears a function to obtain a characteristic energy (C3) porkchop plot called plot\\_porkchop, an example of its usage and how it looks is shown in the Example Problem 2.","category":"page"},{"location":"modules/orbitalPlots/","page":"Orbital Visualization","title":"Orbital Visualization","text":"Function Name Inputs Functionality\nplotorbitperifocal coe::MyCOE<br>planet_radius::Float64 Plot the orbit around a planet and the position of the satellite on it in the perifocal plane (2D)\nplotorbitECI coe::MyCOE<br>planet_radius::Float64<br>mu::Float64 Plot the orbit around a planet and the position of the satellite on it in the ECI frame (3D)\nplot_porkchop tlaunch::Vector [days]<br>ttravel::Vector [days]<br>porkplot::Matrix [km^2/s^2]<br>tsynodic::Number [days] Plot the C3 porkchop from a matrix of length(tlaunch) x length(ttravel) containing the characteristic energy","category":"page"},{"location":"modules/orbitalPerturbations/#Orbital-Perturbations","page":"Orbital Perturbations","title":"Orbital Perturbations","text":"","category":"section"},{"location":"modules/orbitalPerturbations/","page":"Orbital Perturbations","title":"Orbital Perturbations","text":"Within the field of astrodynamics, the accurate propagation of orbits is of paramount importance. Orbital perturbations, such as those caused by the Earth's oblateness (J2 term), and atmospheric drag, can significantly affect the trajectory of a satellite or spacecraft. To address these perturbations and enable precise orbit prediction, the orbitalPerturbations.jl file has been developed. The following table shows the functions available inside the module.","category":"page"},{"location":"modules/orbitalPerturbations/","page":"Orbital Perturbations","title":"Orbital Perturbations","text":"Function Name Inputs Outputs Functionality\nJ2_acceleration r::Vector apJ2::Vector Calculate the perturbation acceleration due to the Earth's oblateness.\ndrag_acceleration alt::Float64<br>v::Vector<br>Bc::Float64 apdrag::Vector Calculate the perturbation acceleration due to the drag on Earth.\ncowell r0::Vector{Float64}<br>v0::Vector{Float64}<br>Bc::Float64<br>t::Vector<br>flagdrag::Bool<br>flagJ2::Bool r::Vector<br>v::Vector Propagate the orbit using Cowell's method given the initial conditions and a vector of time instants for which the solution will be provided. It can consider the drag and/or J2 perturbations if desired.","category":"page"},{"location":"modules/orbitalPerturbations/","page":"Orbital Perturbations","title":"Orbital Perturbations","text":"One widely used propagator is the Cowell's method, which provides a numerical solution to the equations of motion by accounting for the perturbing forces. These perturbing forces are all summed together to form the total force acting on the orbiting body, and then this total force is numerically integrated starting from the initial position. This way, the Cowell's method propagates the orbit over time by iteratively advancing the state vector of the object, while considering the effects of gravitational perturbations, atmospheric drag, and other external forces.","category":"page"},{"location":"modules/orbitalManeuvers/#Orbital-Maneuvers","page":"Orbital Maneuvers","title":"Orbital Maneuvers","text":"","category":"section"},{"location":"modules/orbitalManeuvers/","page":"Orbital Maneuvers","title":"Orbital Maneuvers","text":"The precise control and execution of orbital maneuvers play a critical role in space missions and satellite operations. The orbitalManeuvers.jl file offers a comprehensive set of functions to obtain the delta-v costs of different orbital maneuvers in space; to help students obtain the preliminary estimations performed in the early stages of planning any space mission. These functions, listed in the table, are designed to address some specific maneuver scenarios and requirements. Therefore, enabling them to determine the optimal strategies for achieving the desired orbital configurations.","category":"page"},{"location":"modules/orbitalManeuvers/","page":"Orbital Maneuvers","title":"Orbital Maneuvers","text":"One of the fundamental maneuvers supported by the module is the Hohmann transfer, which allows the transfer of a spacecraft or satellite between two coplanar orbits. It also includes functions for performing plane change maneuvers, and some approximations for low-thrust maneuvers, these latter maneuvers are typically executed by utilizing continuous and low-thrust propulsion systems. ","category":"page"},{"location":"modules/orbitalManeuvers/","page":"Orbital Maneuvers","title":"Orbital Maneuvers","text":"Function Name Inputs Outputs Functionality\nHohmannTransfer_circular r1::Float64<br>r2::Float64<br>mu::Float64 deltaV::Float64 Hohmann transfer between 2 circular and coplanar orbits\nHohmannTransfer_elliptic rp1::Float64<br>e1::Float64<br>rp2::Float64<br>e2::Float64<br>mu::Float64 deltaV::Float64 Hohmann transfer between 2 elliptic and coplanar orbits\nplaneChange_circular ra::Float64<br>delta_i::Float64<br>mu::Float64 deltaV::Float64 Obtain the Δv required to perform a Plane Change Maneuver between 2 circular orbits\nplaneChange_apoapsis2apoapsis stateVector1::MyStateVector<br>stateVector2::MyStateVector<br>delta_i::Float64<br>mu::Float64<br>–––––––––––––––––-<br>coe1::MyCOE<br>coe2::MyCOE<br>mu::Float64 deltaV::Float64 Obtain the min Δv required to perform a Plane Change Maneuver between 2 elliptical orbits\nLowThrustorbitRaisingcircular r1::Float64<br>r2::Float64<br>mu::Float64 deltaV::Float64 Low Thrust Orbit Raising between 2 circular and coplanar orbits\nLowThrustplaneChangecircular ra::Float64<br>delta_i::Float64<br>mu::Float64 deltaV::Float64 Low Thrust Plane Change Maneuver between two circular orbits with the same radius (ra)\nHohmannTransfer_tof coe1::MyCOE<br>coe2::MyCOE<br>tof::Float64<br>mu::Float64 deltaV::MyVector<br>vT1::MyVector<br>vT2::MyVector Given a desired time of flight and the COE of two orbits, calculate the Δv vector and the velocity vectors at the beginning and at the end of the Hohmann transfer.","category":"page"},{"location":"modules/linearAlgebraTypes/#Linear-Algebra-Types","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"","category":"section"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"In order to be able to perform operations more at ease and to store information easily, different linear algebra types were created. Their main feature is that through different constructors the user can pass the components they desire and these will always be stored in the Canonical Reference Frame or Basis. Having all vectors, points, vector bases, and reference frame components stored in only one basis/reference frame allows to speed the computation and to reduce the amount of possible errors.","category":"page"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"The diagram below shows the five different types defined in the linear algebra module. Below each type, it can be seen the objects they store and the type of each of them (indicated as \\textit{fieldName::Type}). To access the field value inside the object it is only necessary to write the name of the variable followed by the fieldName. For example, if 'B1' is MyBasis object and I want to access its angular velocity, I would just have to type 'B1.omega'.","category":"page"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"(Image: Alt text for screen readers)","category":"page"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"All these linear algebra types are related among each other, that is why it was so important to get the chain of dependency between them correctly. This is where constructors come in. The Julia language allows to have more than one way to build a type/struct. Thanks to this feature, the user can have a vector v₁ expressed in vector basis B₁, and if both v₁ and B₁ (which must be a MyBasis, this means, it must be expressed with respect to the Canonical Basis) are passed, v₁ can be turned into a MyVector. This means simply that v₁ is stored internally with the coordinates with respect to the Canonical Basis. So, now, we will examine which are the different available constructors for each of the types.","category":"page"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"MyVector: stores a vector of length three in the canonical right-handed vector basis B₀. These are its possible constructors:\nMyVector(c₀), where c₀ is a Vector{Float64} of length = 3 already expressed in the Canonical Basis.\nMyVector(c₁, B₁), where c₁ is a Vector{Float64} expressed in vector basis B₁, which is a MyBasis object.\nMyVector(x₀, y₀, z₀), where x₀, y₀, and z₀ are the vector components (numbers) already expressed in the Canonical Basis.\nMyVector(x₁, y₁, z₁, B₁), where x₁, y₁, and z₁ are the vector components (numbers) expressed in vector basis B₁, which is a MyBasis object.\nMyVector(), which simply builds a MyVector object full of zeros.","category":"page"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"MyBasis: defines a vector basis (i.e., B₁) by storing its unit vectors, angular velocity, and angular acceleration with respect to the canonical basis B₀. These are the possible constructors:\nMyBasis(i₁₀, j₁₀, k₁₀, omega₁₀, alpha₁₀), where all are MyVector objects. i₁₀, j₁₀, k₁₀ are the unit vectors of vector basis B₁, and omega₁₀ and alpha₁₀ are the angular velocity and angular acceleration, respectively.\nMyBasis(i₂₁, j₂₁, k₂₁, omega₂₁, alpha₂₁, B₁), where all are Vector{Float64} which express the vector basis B₂, with respect to the vector basis B₁, which is a MyBasis object.\nMyBasis(), which builds the Canonical Basis.","category":"page"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"MyPoint: stores the position, velocity, and acceleration vectors that define a point with respect to the inertial reference frame S₀. These are the possible constructors:\nMyPoint(pos, veloc, accel), where pos, veloc, and accel are the position, velocity, and acceleration vectors already MyVector objects as they are expressed with respect to the Canonical Reference Frame.\nMyPoint(pos₁, veloc₁, accel₁, RF₁), where pos₁, veloc₁, and accel₁ are Vector{Float64} expressed with respect to the reference frame RF₁, which is a MyReferenceFrame object.\nMyPoint(), which builds the Canonical Origin Point. This is just an empty point in the Canonical Reference Frame.","category":"page"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"MyReferenceFrame: defined by a vector basis (i.e., B₁) which is a MyBasis object and a point (i.e., P₁) which is a MyPoint object. These are the possible constructors:\nMyReferenceFrame(basis, origin), where basis is a MyBasis object and origin is a MyPoint object.\nMyReferenceFrame(), which returns the inertial reference frame, whose basis is the Canonical Basis and origin point is the Canonical Origin Point.","category":"page"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"MyParticle: object that defines the point particle by storing the point, which is a MyPoint object, and its associated mass. This is the constructor:\nMyParticle(point, mass), where point is a MyPoint object and mass is just a number.","category":"page"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"Some useful objects have been also predefined, so that the user can simply call them every time they are needed, allowing therefore to save time. These predefined objects are the canonical vector basis B_0, the three canonical unitary vectors (mathbfi_0mathbfj_0mathbfk_0), the canonical origin point O_0, and the canonical/inertial reference frame S_0. They can simply be used by typing their correct name, which appear highlighted below:","category":"page"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"CanonicalBasis = MyBasis(MyVector([1.0, 0.0, 0.0]), MyVector([0.0, 1.0, 0.0]), MyVector([0.0, 0.0, 1.0]), MyVector([0.0, 0.0, 0.0]), MyVector([0.0, 0.0, 0.0]))\ni0 = MyVector([1.0, 0.0, 0.0])\nj0 = MyVector([0.0, 1.0, 0.0])\nk0 = MyVector([0.0, 0.0, 1.0])\nCanonicalOriginPoint = MyPoint(MyVector([0.0, 0.0, 0.0]), MyVector([0.0, 0.0, 0.0]), MyVector([0.0, 0.0, 0.0]))\nCanonicalReferenceFrame = MyReferenceFrame(MyBasis(MyVector([1.0, 0.0, 0.0]), MyVector([0.0, 1.0, 0.0]), MyVector([0.0, 0.0, 1.0]), MyVector([0.0, 0.0, 0.0]), MyVector([0.0, 0.0, 0.0])), MyPoint(MyVector([0.0, 0.0, 0.0]), MyVector([0.0, 0.0, 0.0]), MyVector([0.0, 0.0, 0.0])))","category":"page"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"Both recipes and functions have been implemented to allow plotting MyBasis and MyReferenceFrame objects in 3D. The only difference in their usage is that for the recipes it is required to include again the Plots.jl package, by writing before:using Plots. The proper way to call this functions or recipes is addressed in the table below:","category":"page"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"Function call Recipe call Functionality\nplot_MyBasis(B1) plot(B1) Plot the MyBasis object B1 in 3D using either the function or the recipe\nplot_MyReferenceFrame(RF1) plot(RF1) Plot the MyReferenceFrame object S1 in 3D using either the function or the recipe","category":"page"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"In addition, some useful functions have also been created to assist in changing of reference frame, rotating vector basis, and more. ","category":"page"},{"location":"modules/linearAlgebraTypes/","page":"Linear Algebra Types","title":"Linear Algebra Types","text":"Function Name Inputs Outputs Functionality\ncomponentsInBasis v::MyVector<br>B1::MyBasis v1::Vector Project a MyVector object onto a basis B₁\nposvelacc_inRF point::MyPoint<br>RF1::MyReferenceFrame pos1::Vector<br>veloc1::Vector<br>accel1::Vector Obtain the position, velocity, and acceleration vectors of a MyPoint object in a different reference frame S₁\nrotation_matrix basis::MyBasis R::Matrix Obtain the Rotation Matrix [₀R₁] of a MyBasis object B₁\npurerotationMyBasis_x basis::MyBasis<br>theta::Number rotB::MyBasis Obtain the new MyBasis object after a pure rotation about the x-axis\npurerotationMyBasis_y basis::MyBasis<br>theta::Number rotB::MyBasis Obtain the new MyBasis object after a pure rotation about the y-axis\npurerotationMyBasis_z basis::MyBasis<br>theta::Number rotB::MyBasis Obtain the new MyBasis object after a pure rotation about the z-axis","category":"page"},{"location":"#AstrodynamicsEdu.jl-Documentation","page":"Home","title":"AstrodynamicsEdu.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Welcome to the documentation for AstrodynamicsEdu, an educational package designed to provide  a comprehensive understanding of orbital dynamics. This documentation serves as a guide for  students, educators, and enthusiasts interested in exploring the fascinating world of astrodynamics.","category":"page"},{"location":"","page":"Home","title":"Home","text":"AstrodynamicsEdu offers a wide range of features to facilitate learning and problem-solving in the  field of orbital dynamics. Let's take a closer look at the key features offered by this package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Solving Problems of the Ideal Two-Body Problem.\nChange of Reference Frame: AstrodynamicsEdu supports the transformation of orbital elements and ","category":"page"},{"location":"","page":"Home","title":"Home","text":"state vectors between different reference frames, including inertial frames, rotating frames, and  non-inertial frames.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Orbital Maneuvers and Delta-v Computation.\nOrbital Perturbations: AstrodynamicsEdu incorporates models for common perturbations, including ","category":"page"},{"location":"","page":"Home","title":"Home","text":"atmospheric drag and Earth's oblateness.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Orbit Visualization and Plotting.\nEducational Resources and Examples: To support the learning process, AstrodynamicsEdu provides a ","category":"page"},{"location":"","page":"Home","title":"Home","text":"collection of educational resources, sample problems, and examples.","category":"page"},{"location":"","page":"Home","title":"Home","text":"We hope that AstrodynamicsEdu and this documentation empower you on your journey to mastering orbital  dynamics.","category":"page"},{"location":"#Getting-Started:-Installation-And-First-Steps","page":"Home","title":"Getting Started: Installation And First Steps","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"As this package has not been registered yet, to run this package you need to write the following  commands in your Julia REPL terminal to install the package:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using Pkg\r\nPkg.activate(\".\")\r\nPkg.instantiate()\r\nPkg.add(url=\"https://github.com/AliciaSBa/AstrodynamicsEdu.jl.git\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"Once it has been registered, it will only be necessary to run the following command to install it:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pkg.add(\"AstrodynamicsEdu\")","category":"page"},{"location":"","page":"Home","title":"Home","text":"To load the package, use the command:","category":"page"},{"location":"","page":"Home","title":"Home","text":"using AstrodynamicsEdu","category":"page"},{"location":"#Package-Structure","page":"Home","title":"Package Structure","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The AstrodynamicsEdu package is composed by six different submodules, each designed to provide a  different set of capabilities related with Orbital Dynamics. The different functionalities and  details of each specific module can be found on its respective documentation page.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\r\n\"modules/linearAlgebraTypes.md\",\r\n\"modules/idealTwoBodyProblem.md\"\r\n]\r\nDepth = 2","category":"page"},{"location":"#Examples","page":"Home","title":"Examples","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"To help you kick-start using the AstrodynamicsEdu package, a set of extensive orbital dynamics problems are provided as examples. These problems have been taken from the course of Space Vehicles  and Orbital Dynamics from University Carlos III of Madrid (uc3m). You can find the example  problems below:","category":"page"},{"location":"","page":"Home","title":"Home","text":"Pages = [\r\n    \"tutorials/example1.md\",\r\n]\r\nDepth = 2","category":"page"},{"location":"modules/idealTwoBodyProblem/#Ideal-Two-Body-Problem","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"","category":"section"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"The study of the ideal two-body problem forms the core of our codebase, serving as the foundation for more complex algorithms and calculations in orbital dynamics. This module introduces two key types: the state vector and the coe (classical orbital elements); and provides a comprehensive set of functions that enable precise analysis and prediction of celestial motion.","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"The ideal two-body problem focuses on the motion of two point masses, assuming no external influences from other celestial bodies. Although this simplification may appear trivial, it serves as a fundamental building block for understanding and modeling more intricate orbital dynamics scenarios.","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"Within the idealTwoBodyProblem.jl file, a range of functions has been developed to address various aspects of the ideal two-body problem. These functions form the backbone of orbital computations, providing essential tools for the calculation of critical parameters and transformations.","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"The figure below shows the two new data types defined in the ideal two-body problem file: MyStateVector and MyCOE. Below each appears their store objects and their type (indicated as fieldName::Type). These two data types are crucial for astrodynamics, as they allow to completely describe the motion of a body in space.","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"(Image: Alt text)","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"It is important to understand what each of these types entails and how to construct them:","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"MyStateVector: stores the position vector (r) and the velocity vector (v) of a body in space. Although there is no general imposition on the units, because of the nature of distances in space, the position of the satellite/spacecraft is usually given in km, while the velocity is given in km/s. Providing the coordinates in these units ensures the correct functioning of all the functions in the code. There is only one possible way to construct a MyStateVector object, and it is as follows:\nMyStateVector(r, v), where both r and v must be MyVector objects.","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"MyCOE: stores all six classical orbital elements (Ω, i, ω, a, e, θ), and p, so that the orbit can always be well defined. This is because of the peculiarity of the parabolic orbit, where a = ∞. However, for the construction, only six of the elements are given, where the user can choose to either provide the semi-major axis a or the semi-latus rectum p, but never both. However, this seventh element can always be accessed as it is computed internally. It is very important to note that all the angles must be given in radians, which is not optional. Additionally, all the parameters must be of type Float64. Examples for each constructor are provided below:\nMyCOE(RAAN = 0.18, inc = 0.26, omega = 0.30, a = 12000.0, e = 0.54, theta = π), where a is provided and p is computed internally.\nMyCOE(RAAN = 0.52, inc = 0.0, omega = 0.92, p = 8000.0, e = 1.0, theta = 2.09), where p is provided and a is computed internally.","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"This first table presents an overview of the functions available within the ideal two-body problem file. These functions encompass a wide range of functionalities, including the computation of the angular momentum vector, the conversion between state vectors and classical orbital elements, and the propagation of state vectors over time. With a total of 26 functions, this comprehensive set ensures that users have the necessary tools to accurately analyze and simulate the motion of celestial objects.","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"Function Name Inputs Outputs Functionality\nangularMomentumVector stateVector::MyStateVector h::MyVector Obtain h vector\nmechanicalEnergy stateVector::MyStateVector, mu::Float64 xi::Float64 Obtain ξ\neccentricityVector stateVector::MyStateVector, mu::Float64 e::MyVector Obtain e vector\nsemilatusRectum stateVector::MyStateVector, mu::Float64 p::Float64 Obtain p\nperiodOrbit stateVector::MyStateVector, mu::Float64, OrbitType::String period::Float64 Obtain period τ [s]\nperifocalBasis stateVector::MyStateVector, mu::Float64 perifocalBasis::MyBasis Perifocal Basis\nperiapsis stateVector::MyStateVector, mu::Float64 r_p::Float64 Obtain r_p\napoapsis stateVector::MyStateVector, mu::Float64 r_a::Float64 Obtain r_a\ntrajectoryEquation stateVector::MyStateVector, mu::Float64, theta::Float64 trajectoryEquation::Float64 Obtain r\ninclination stateVector::MyStateVector inc::Float64 Obtain i\nsemiMajorAxis stateVector::MyStateVector, mu::Float64 a::Float64 Obtain a\norbitType stateVector::MyStateVector, mu::Float64 orbitType::String Obtain orbit type: - Elliptic - Hyperbolic - Parabolic - Circular\ntrueAnomaly stateVector::MyStateVector, mu::Float64 theta::Float64 Obtain θ [rad]\nstateVectortoCOE stateVector::MyStateVector, mu::Float64 coe::MyCOE (r, v) → COE\nCOEtostateVector coe::MyCOE, mu::Float64 stateVector::MyStateVector COE → (r, v)\nescapeVelocity r::MyVector, mu::Float64 v_esc::Float64 Obtain v_e\ncircularVelocity 2 OPTIONS: - r::MyVector, mu::Float64 - r_norm::Float64, mu::Float64 v_circ::Float64 Obtain v_c\nvelocityPeriapsis stateVector::MyStateVector, mu::Float64 v_p::Float64 Obtain v_p\nvelocityApoapsis stateVector::MyStateVector, mu::Float64 v_a::Float64 Obtain v_a\nvelocityHyperbolicAsymptote stateVector::MyStateVector, mu::Float64 v_h::Float64 Obtain v_h\nspeed_visViva r_norm::Float64, a::Float64, mu::Float64 v::Float64 Obtain v\nrightAscensionOfTheAscendingNode stateVector::MyStateVector RAAN::Float64 Obtain Ω\nargumentOfPeriapsis stateVector::MyStateVector, mu::Float64 omega::Float64 Obtain ω\nvectorinECItoperifocal ECI_vector::Vector, coe::MyCOE perifocalVector::MyVector r_ECI → r_PQW\nvectorinperifocaltoECI perifocalVector::Vector, coe::MyCOE ECI_vector::MyVector r_PQW → r_ECI\npropagate_StateVector stateVector::MyStateVector, mu::Float64, delta_t::Float64 stateVector2::MyStateVector Propagate (r, v) by Δt","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"Additionally, as displayed on the second table, the file incorporates functions specific to Kepler's problem, which focuses on the motion of bodies under the influence of a central gravitational force. The aim of this part is to be able to relate time and position. In order to achieve that, it is necessary to be able to convert between the different anomalies at ease. These conversions differ depending on the orbit type (elliptic, parabolic or hyperbolic), and obtaining them can become quite tricky. Because for the path from the time to the auxiliary anomaly, an iterative numerical method is needed. In our code, the Newton-Raphson method was used, provided by the Roots package. ","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"However, in the code not only the specific cases are developed. We also incorporated the universal formulation of Kepler's equation to solve for the universal anomaly chi which applied an Stumpff function and the numerical solver.","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"Function Name Inputs Outputs Functionality\ntimeSincePeriapsis stateVector::MyStateVector, mu::Float64, theta::Float64 time::Float64 theta [rad] rightarrow Delta t [s]\ntimeSinceTrueAnomaly stateVector::MyStateVector, mu::Float64, theta1::Float64, theta2::Float64 time::Float64 Delta t between theta_1 & theta_2\nstumpffFunction z::Float64 S::Float64 Stumpff function\nuniversalAnomaly stateVector::MyStateVector, mu::Float64, time::Float64 X::Float64 Delta t rightarrow chi\nuniversalAnomalytotrueAnomaly stateVector::MyStateVector, mu::Float64, X::Float64 theta::Float64 chi rightarrow theta\ntrueAnomalytouniversalAnomaly stateVector::MyStateVector, mu::Float64, theta::Float64 X::Float64 theta rightarrow chi\ntimeSincePeriapsistotrueAnomaly stateVector::MyStateVector, mu::Float64, time::Float64 theta::Float64 Delta t rightarrow theta\ntrueAnomalytoeccentricAnomaly stateVector::MyStateVector, mu::Float64, theta::Float64 E::Float64 theta rightarrow E\neccentricAnomalytotrueAnomaly stateVector::MyStateVector, mu::Float64, E::Float64 theta::Float64 E rightarrow theta\neccentricAnomalytomeanAnomaly stateVector::MyStateVector, mu::Float64, E::Float64 Me::Float64 E rightarrow M_e\nmeanAnomalytoeccentricAnomaly stateVector::MyStateVector, mu::Float64, Me::Float64 E::Float64 M_e rightarrow E\ntrueAnomalytomeanAnomaly_E stateVector::MyStateVector, mu::Float64, theta::Float64 Me::Float64 theta rightarrow M_e\nmeanAnomalytotrueAnomaly_E stateVector::MyStateVector, mu::Float64, Me::Float64 theta::Float64 M_e rightarrow theta\nuniversalAnomalytoeccentricAnomaly stateVector::MyStateVector, mu::Float64, X::Float64 E::Float64 chi rightarrow E\neccentricAnomalytouniversalAnomaly stateVector::MyStateVector, mu::Float64, E::Float64 X::Float64 E rightarrow chi\ntimeSincePeriapsistoMe stateVector::MyStateVector, mu::Float64, time::Float64 Me::Float64 Delta t rightarrow M_e\nMetotimeSincePeriapsis stateVector::MyStateVector, mu::Float64, Me::Float64 time::Float64 M_e rightarrow Delta t\ntrueAnomalytoparabolicAnomaly stateVector::MyStateVector, mu::Float64, theta::Float64 P::Float64 theta rightarrow P\nparabolicAnomalytotrueAnomaly stateVector::MyStateVector, mu::Float64, P::Float64 theta::Float64 P rightarrow theta\nparabolicAnomalytomeanAnomaly stateVector::MyStateVector, mu::Float64, P::Float64 Mp::Float64 P rightarrow M_p\nmeanAnomalytoparabolicAnomaly stateVector::MyStateVector, mu::Float64, Mp::Float64 P::Float64 M_p rightarrow P\ntrueAnomalytomeanAnomaly_P stateVector::MyStateVector, mu::Float64, theta::Float64 Mp::Float64 theta rightarrow M_p\nmeanAnomalytotrueAnomaly_P stateVector::MyStateVector, mu::Float64, Mp::Float64 theta::Float64 M_p rightarrow theta\nuniversalAnomalytohyperbolicAnomaly stateVector::MyStateVector, mu::Float64, X::Float64 H::Float64 chi rightarrow H\nhyperbolicAnomalytouniversalAnomaly stateVector::MyStateVector, mu::Float64, H::Float64 X::Float64 H rightarrow chi\ntimeSincePeriapsistoMh stateVector::MyStateVector, mu::Float64, time::Float64 Mh::Float64 Delta t rightarrow M_h\nMhtotimeSincePeriapsis stateVector::MyStateVector, mu::Float64, Mh::Float64 time::Float64 M_h rightarrow Delta t\ntrueAnomalytomeanAnomaly_H stateVector::MyStateVector, mu::Float64, theta::Float64 Mh::Float64 theta rightarrow M_h\nmeanAnomalytotrueAnomaly_H stateVector::MyStateVector, mu::Float64, Mh::Float64 theta::Float64 M_h rightarrow theta\nuniversalAnomalytohyperbolicAnomaly stateVector::MyStateVector, mu::Float64, X::Float64 H::Float64 chi rightarrow H\nhyperbolicAnomalytouniversalAnomaly stateVector::MyStateVector, mu::Float64, H::Float64 X::Float64 H rightarrow chi\ntimeSincePeriapsistoMh stateVector::MyStateVector, mu::Float64, time::Float64 Mh::Float64 Delta t rightarrow M_h\nMhtotimeSincePeriapsis stateVector::MyStateVector, mu::Float64, Mh::Float64 time::Float64 M_h rightarrow Delta t","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"To better understand all the possible directions of conversion between the different anomalies and time, the diagram below can be consulted.","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"(Image: Alt text)","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"Inside the file, the initial orbit determination is also tackled through the Lambert's problem. The functions written in this third table facilitate the determination of the time of flight, conic section parameters, and the solution of Lambert's problem itself.","category":"page"},{"location":"modules/idealTwoBodyProblem/","page":"Ideal Two Body Problem","title":"Ideal Two Body Problem","text":"Function Name Inputs Outputs Functionality\nLambert_solve r1::MyVector, r2::MyVector, tF::Float64, mu::Float64, k::MyVector coe1::MyCOE, coe2::MyCOE Given two positions mathbfr_1 and mathbfr_2 and the time of flight between them, find the orbit that connects them\nLambert_conic r1::MyVector, r2::MyVector, eT::Float64, k::MyVector coe1::MyCOE, coe2::MyCOE Obtain the conic section for a given transverse eccentricity e_T using the Avanzini algorithm\ntimeOfFlight coe1::MyCOE, coe2::MyCOE, mu::Float64, theta2::Float64, mu::Float64 delta_t::Float64 Time of flight between two true anomalies (theta_1 and theta_2)","category":"page"}]
}
